name: "Main Release"

on:
  push:
    branches: [main]
    paths-ignore:
      - "**.md"
      - "docs/**"
      - ".github/**.md"
      - "README.md"
      - "CHANGELOG.md"
  workflow_dispatch:
    inputs:
      force_release:
        description: "Force a release even if no changesets"
        required: false
        default: false
        type: boolean
      release_type:
        description: "Type of release"
        required: false
        default: "auto"
        type: choice
        options:
          - auto
          - patch
          - minor
          - major

concurrency:
  group: main-release
  cancel-in-progress: false

jobs:
  # Step 1: Determine if we should release
  check-release:
    name: "Check Release Status"
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      version: ${{ steps.check.outputs.version }}
      has_changesets: ${{ steps.check.outputs.has_changesets }}
      is_changeset_release: ${{ steps.check.outputs.is_changeset_release }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check release conditions
        id: check
        run: |
          # Check if this is a changeset release commit
          COMMIT_MSG=$(git log -1 --pretty=format:"%s")
          echo "Latest commit: $COMMIT_MSG"

          # Check recent commits for changeset patterns (look deeper for merge commits)
          RECENT_COMMITS=$(git log -10 --pretty=format:"%s")
          echo "Recent commits:"
          echo "$RECENT_COMMITS"

          IS_CHANGESET_RELEASE="false"
          if [[ "$COMMIT_MSG" == *"chore: release version packages"* ]] || \
             [[ "$COMMIT_MSG" == *"Version Packages"* ]] || \
             [[ "$COMMIT_MSG" == *"changeset-release/main"* ]] || \
             [[ "$COMMIT_MSG" == *"chore: sync version files"* ]] || \
             [[ "$RECENT_COMMITS" == *"chore: release version packages"* ]] || \
             [[ "$RECENT_COMMITS" == *"Version Packages"* ]] || \
             [[ "$RECENT_COMMITS" == *"chore: sync version files"* ]]; then
            IS_CHANGESET_RELEASE="true"
            echo "‚úÖ This is a changeset release commit"
          fi

          # Check for pending changesets with better detection
          HAS_CHANGESETS="false"
          CHANGESET_COUNT=0
          if [ -d ".changeset" ]; then
            # Count actual changeset files (excluding README.md and config.json)
            CHANGESET_COUNT=$(find .changeset -name "*.md" -not -name "README.md" -not -name "config.json" 2>/dev/null | wc -l)
            if [ "$CHANGESET_COUNT" -gt 0 ]; then
              HAS_CHANGESETS="true"
              echo "‚úÖ Found $CHANGESET_COUNT pending changesets"
              # List the changeset files for debugging
              echo "Changeset files:"
              find .changeset -name "*.md" -not -name "README.md" -not -name "config.json" 2>/dev/null | head -5
            fi
          fi

          # Enhanced version change detection
          VERSION_CHANGED="false"
          VERSION_FILES_CHANGED=""
          if git diff HEAD~1 HEAD --name-only | grep -q "package.json\|src-tauri/Cargo.toml\|src-tauri/tauri.conf.json"; then
            VERSION_FILES_CHANGED=$(git diff HEAD~1 HEAD --name-only | grep -E "package.json|src-tauri/Cargo.toml|src-tauri/tauri.conf.json" | tr '\n' ' ')
            echo "üì¶ Version files changed in recent commit: $VERSION_FILES_CHANGED"
            VERSION_CHANGED="true"
          fi

          # Check for manual version bumps in commit messages
          MANUAL_VERSION_BUMP="false"
          if [[ "$COMMIT_MSG" == *"bump version"* ]] || [[ "$COMMIT_MSG" == *"version"* ]] && [[ "$COMMIT_MSG" == *"v"* ]]; then
            MANUAL_VERSION_BUMP="true"
            echo "üì¶ Manual version bump detected in commit message"
          fi

          # Determine if we should release with improved logic
          SHOULD_RELEASE="false"
          RELEASE_REASON=""

          if [[ "$IS_CHANGESET_RELEASE" == "true" ]]; then
            SHOULD_RELEASE="true"
            RELEASE_REASON="changeset release commit"
          elif [[ "$HAS_CHANGESETS" == "true" && "$VERSION_CHANGED" == "true" ]]; then
            SHOULD_RELEASE="true"
            RELEASE_REASON="changesets present and version files updated"
          elif [[ "${{ github.event.inputs.force_release }}" == "true" ]]; then
            SHOULD_RELEASE="true"
            RELEASE_REASON="manual force release"
          elif [[ "$HAS_CHANGESETS" == "true" && "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_RELEASE="true"
            RELEASE_REASON="manual dispatch with pending changesets"
          elif [[ "$MANUAL_VERSION_BUMP" == "true" ]]; then
            SHOULD_RELEASE="true"
            RELEASE_REASON="manual version bump detected"
          fi

          if [[ "$SHOULD_RELEASE" == "true" ]]; then
            echo "‚úÖ Release conditions met: $RELEASE_REASON"
          else
            echo "‚ÑπÔ∏è No release needed"
            echo "  - Changeset release: $IS_CHANGESET_RELEASE"
            echo "  - Version changed: $VERSION_CHANGED"
            echo "  - Has changesets: $HAS_CHANGESETS"
            echo "  - Manual bump: $MANUAL_VERSION_BUMP"
            echo "  - Force release: ${{ github.event.inputs.force_release }}"
          fi

          # Get current version with validation
          VERSION=$(node -p "require('./package.json').version")
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ö†Ô∏è Warning: Version format may be invalid: $VERSION"
          fi

          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "has_changesets=$HAS_CHANGESETS" >> $GITHUB_OUTPUT
          echo "is_changeset_release=$IS_CHANGESET_RELEASE" >> $GITHUB_OUTPUT
          echo "release_reason=$RELEASE_REASON" >> $GITHUB_OUTPUT

  # Step 2: Pre-release validation
  pre-release-validation:
    name: "Pre-Release Validation"
    runs-on: ubuntu-latest
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'
    outputs:
      validation_passed: ${{ steps.validate.outputs.passed }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install system dependencies for validation
        if: runner.os == 'Linux'
        run: |
          echo "üì¶ Installing system dependencies for validation..."
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf libglib2.0-dev curl wget unzip
          echo "‚úÖ System dependencies installed"

      - name: Run comprehensive validation
        id: validate
        run: |
          echo "üîç Running pre-release validation..."
          VALIDATION_PASSED="true"
          VALIDATION_ERRORS=""

          # 1. Check for security vulnerabilities
          echo "üîí Checking for security vulnerabilities..."
          if ! pnpm audit --audit-level moderate; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Security vulnerabilities found. "
            VALIDATION_PASSED="false"
          fi

          # 2. Validate package.json version format
          echo "üì¶ Validating version format..."
          VERSION=$(node -p "require('./package.json').version")
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Invalid version format: $VERSION. "
            VALIDATION_PASSED="false"
          fi

          # 3. Check for uncommitted changes
          echo "üìù Checking for uncommitted changes..."
          if ! git diff --quiet; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Uncommitted changes detected. "
            VALIDATION_PASSED="false"
          fi

          # 4. Validate Tauri configuration
          echo "‚öôÔ∏è Validating Tauri configuration..."
          if ! node -e "JSON.parse(require('fs').readFileSync('src-tauri/tauri.conf.json', 'utf8'))"; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Invalid tauri.conf.json. "
            VALIDATION_PASSED="false"
          fi

          # 5. Check for breaking changes in changesets
          echo "‚ö†Ô∏è Checking for breaking changes..."
          if [ -d ".changeset" ]; then
            BREAKING_CHANGES=$(find .changeset -name "*.md" -not -name "README.md" -not -name "config.json" -exec grep -l "BREAKING CHANGE\|!" {} \; 2>/dev/null | wc -l)
            if [ "$BREAKING_CHANGES" -gt 0 ]; then
              echo "‚ö†Ô∏è Found $BREAKING_CHANGES changesets with breaking changes"
            fi
          fi

          # 6. Validate build prerequisites (frontend only for validation)
          echo "üî® Validating frontend build prerequisites..."
          if ! pnpm run build; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Frontend build failed. "
            VALIDATION_PASSED="false"
          fi

          # 7. Setup JRE for Tabula (required for Rust build)
          echo "üîß Setting up JRE for Tabula..."
          if ! bash src-tauri/scripts/setup-build-jre.sh; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}JRE setup failed. "
            VALIDATION_PASSED="false"
          else
            echo "‚úÖ JRE setup completed"
          fi

          # 8. Check Rust/Cargo configuration
          echo "ü¶Ä Validating Rust configuration..."
          cd src-tauri

          # Validate Cargo configuration with system dependencies
          if ! cargo check --quiet; then
            VALIDATION_ERRORS="${VALIDATION_ERRORS}Cargo check failed. "
            VALIDATION_PASSED="false"
          else
            echo "‚úÖ Cargo configuration is valid"
          fi
          cd ..

          if [[ "$VALIDATION_PASSED" == "true" ]]; then
            echo "‚úÖ All pre-release validations passed"
          else
            echo "‚ùå Validation failed: $VALIDATION_ERRORS"
            echo "Please fix the issues above before proceeding with the release."
          fi

          echo "passed=$VALIDATION_PASSED" >> $GITHUB_OUTPUT

  # Step 3: Handle changesets (version bumping)
  handle-changesets:
    name: "Handle Changesets"
    runs-on: ubuntu-latest
    needs: [check-release, pre-release-validation]
    if: needs.check-release.outputs.has_changesets == 'true' && needs.check-release.outputs.is_changeset_release == 'false' && needs.pre-release-validation.outputs.validation_passed == 'true'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Create Release Pull Request
        uses: changesets/action@v1
        with:
          version: pnpm run version
          title: "chore: release version packages"
          commit: "chore: release version packages"
          createGithubReleases: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Step 4: Sync versions and create tag
  prepare-release:
    name: "Prepare Release"
    runs-on: ubuntu-latest
    needs: [check-release, pre-release-validation]
    if: needs.check-release.outputs.should_release == 'true' && needs.pre-release-validation.outputs.validation_passed == 'true'
    permissions:
      contents: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Sync versions
        run: |
          echo "üì¶ Syncing all version files..."
          pnpm run sync-versions

          # Check if there are any changes to commit
          if ! git diff --quiet; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .
            git commit -m "chore: sync version files"
            git push
            echo "‚úÖ Version files synced and committed"
          else
            echo "‚ÑπÔ∏è No version sync changes needed"
          fi

      - name: Get version and create tag
        id: version
        run: |
          VERSION=$(node -p "require('./package.json').version")
          TAG="v$VERSION"

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if tag exists locally
          if ! git tag -l "$TAG" | grep -q "$TAG"; then
            # Check if tag exists remotely
            if git ls-remote --tags origin | grep -q "refs/tags/$TAG$"; then
              echo "‚ÑπÔ∏è Tag $TAG already exists remotely, fetching it"
              git fetch origin "refs/tags/$TAG:refs/tags/$TAG"
            else
              echo "üè∑Ô∏è Creating new tag: $TAG"
              git tag -a "$TAG" -m "Release $TAG"
              git push origin "$TAG"
              echo "‚úÖ Created and pushed tag: $TAG"
            fi
          else
            echo "‚ÑπÔ∏è Tag $TAG already exists locally"
          fi

  # Step 5: Build and release desktop
  build-and-release:
    name: "Build & Release"
    needs: [check-release, pre-release-validation, prepare-release]
    if: needs.check-release.outputs.should_release == 'true' && needs.pre-release-validation.outputs.validation_passed == 'true'
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: "macos-latest"
            args: "--target aarch64-apple-darwin"
            target: "aarch64-apple-darwin"
            build_name: "macos-aarch64"
          - platform: "macos-latest"
            args: "--target x86_64-apple-darwin"
            target: "x86_64-apple-darwin"
            build_name: "macos-x64"
          - platform: "ubuntu-22.04"
            args: ""
            target: "x86_64-unknown-linux-gnu"
            build_name: "linux-x64"
          - platform: "windows-latest"
            args: ""
            target: "x86_64-pc-windows-msvc"
            build_name: "windows-x64"

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: lts/*

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install system dependencies (Ubuntu)
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf curl wget unzip

      - name: Install create-dmg (macOS)
        if: matrix.platform == 'macos-latest'
        run: |
          brew install create-dmg

      - name: Import Apple Code Signing Certificate
        if: matrix.platform == 'macos-latest'
        run: |
          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Import certificate
          echo "$APPLE_CERTIFICATE" | base64 --decode > certificate.p12
          security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          # Clean up
          rm certificate.p12
        env:
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}

      - name: Get pnpm store directory
        id: pnpm-cache
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path)" >> $GITHUB_OUTPUT

      - name: Cache pnpm dependencies
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Cache Rust dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            src-tauri/target
          key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-cargo-
            ${{ runner.os }}-cargo-

      - name: Cache Node dependencies
        uses: actions/cache@v4
        with:
          path: |
            app/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Cache Build artifacts
        uses: actions/cache@v4
        with:
          path: |
            app/dist
            app/src-tauri/target/release
          key: ${{ runner.os }}-${{ matrix.build_name }}-build-${{ hashFiles('**/package.json', '**/Cargo.toml', '**/src/**') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.build_name }}-build-

      - name: Cache JRE for Tabula
        uses: actions/cache@v4
        with:
          path: |
            app/src-tauri/resources/build-jre
          key: ${{ runner.os }}-${{ matrix.target }}-jre-${{ hashFiles('app/src-tauri/scripts/setup-build-jre.sh') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.target }}-jre-

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      - name: Setup JRE for Tabula
        shell: bash
        run: bash src-tauri/scripts/setup-build-jre.sh

      - name: Extract changelog for release
        id: changelog
        shell: bash
        continue-on-error: false
        run: |
          set +e  # Disable exit on error for this script
          VERSION="${{ needs.prepare-release.outputs.version }}"

          if [ -f "CHANGELOG.md" ]; then
            # Extract the changelog section for the current version
            CHANGELOG_CONTENT=$(awk -v version="$VERSION" '
              /^## / { 
                if (found) exit
                if ($0 ~ "## .*" version) found=1
                next
              }
              found && /^## / { exit }
              found { print }
            ' CHANGELOG.md | sed '/^$/d' | head -30)
            
            # Debug output
            echo "Debug: VERSION=$VERSION"
            echo "Debug: CHANGELOG_CONTENT length: $(echo "$CHANGELOG_CONTENT" | wc -c | tr -d ' ')"
            if [ -n "$CHANGELOG_CONTENT" ]; then
              echo "Debug: Found changelog content for version $VERSION"
            else
              echo "Debug: No changelog content found for version $VERSION"
            fi
            
            # Get previous version for comparison link
            PREVIOUS_VERSION=$(awk '/^## / && !/'"$VERSION"'/ { print $2; exit }' CHANGELOG.md)
            
            if [ -n "$CHANGELOG_CONTENT" ]; then
              # Analyze change types - handle both "feat:" and "hash: feat:" formats
              FEATURES=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?feat:" | wc -l | tr -d ' ')
              FIXES=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?fix:" | wc -l | tr -d ' ')
              BREAKING=$(echo "$CHANGELOG_CONTENT" | grep -E "BREAKING CHANGE|!" | wc -l | tr -d ' ')
              DOCS=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?docs:" | wc -l | tr -d ' ')
              PERF=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?perf:" | wc -l | tr -d ' ')
              REFACTOR=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?refactor:" | wc -l | tr -d ' ')
              CHORE=$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?chore:" | wc -l | tr -d ' ')
              SECURITY=$(echo "$CHANGELOG_CONTENT" | grep -i "security\|vulnerability\|cve\|exploit" | wc -l | tr -d ' ')
              
              # Count total changes
              TOTAL_CHANGES=$(echo "$CHANGELOG_CONTENT" | grep "^-" | wc -l | tr -d ' ')
              
              # Create formatted changelog with emojis
              FORMATTED_CHANGELOG=""
              if [ "$FEATURES" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### ‚ú® New Features ($FEATURES)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?feat:" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              if [ "$FIXES" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### üêõ Bug Fixes ($FIXES)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?fix:" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              if [ "$BREAKING" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### ‚ö†Ô∏è Breaking Changes ($BREAKING)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "BREAKING CHANGE|!" | sed 's/^- /- /')"$'\n\n'
              fi
              
              if [ "$PERF" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### ‚ö° Performance Improvements ($PERF)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?perf:" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              if [ "$REFACTOR" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### üîß Code Refactoring ($REFACTOR)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?refactor:" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              if [ "$DOCS" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### üìö Documentation ($DOCS)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -E "(^- [a-f0-9]+: )?docs:" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              if [ "$SECURITY" -gt 0 ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### üîí Security Updates ($SECURITY)"$'\n'"$(echo "$CHANGELOG_CONTENT" | grep -i "security\|vulnerability\|cve\|exploit" | sed 's/^- /-  /')"$'\n\n'
              fi
              
              # Add other changes if any
              OTHER_CHANGES=$(echo "$CHANGELOG_CONTENT" | grep -v -E "feat:|fix:|BREAKING CHANGE|!|perf:|refactor:|docs:|chore:|security|vulnerability|cve|exploit" | grep "^-" || true)
              if [ -n "$OTHER_CHANGES" ]; then
                FORMATTED_CHANGELOG="${FORMATTED_CHANGELOG}### üîÑ Other Changes"$'\n'"$OTHER_CHANGES"$'\n\n'
              fi
              
              # If no categorized changes found, use original content
              if [ -z "$FORMATTED_CHANGELOG" ]; then
                FORMATTED_CHANGELOG="$CHANGELOG_CONTENT"
              fi
              
              echo "changelog<<EOF" >> $GITHUB_OUTPUT
              echo "$FORMATTED_CHANGELOG" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              
              # Output change statistics
              echo "features=$FEATURES" >> $GITHUB_OUTPUT
              echo "fixes=$FIXES" >> $GITHUB_OUTPUT
              echo "breaking=$BREAKING" >> $GITHUB_OUTPUT
              echo "docs=$DOCS" >> $GITHUB_OUTPUT
              echo "perf=$PERF" >> $GITHUB_OUTPUT
              echo "refactor=$REFACTOR" >> $GITHUB_OUTPUT
              echo "security=$SECURITY" >> $GITHUB_OUTPUT
              echo "total_changes=$TOTAL_CHANGES" >> $GITHUB_OUTPUT
            else
              echo "changelog=See CHANGELOG.md for details." >> $GITHUB_OUTPUT
              echo "features=0" >> $GITHUB_OUTPUT
              echo "fixes=0" >> $GITHUB_OUTPUT
              echo "breaking=0" >> $GITHUB_OUTPUT
              echo "security=0" >> $GITHUB_OUTPUT
              echo "total_changes=0" >> $GITHUB_OUTPUT
            fi
            
            echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          else
            echo "changelog=No changelog available." >> $GITHUB_OUTPUT
            echo "previous_version=0.0.2" >> $GITHUB_OUTPUT
            echo "features=0" >> $GITHUB_OUTPUT
            echo "fixes=0" >> $GITHUB_OUTPUT
            echo "breaking=0" >> $GITHUB_OUTPUT
            echo "security=0" >> $GITHUB_OUTPUT
            echo "total_changes=0" >> $GITHUB_OUTPUT
          fi

      - name: Generate build timestamp
        id: timestamp
        run: echo "build_time=$(date -u +"%Y-%m-%d %H:%M UTC")" >> $GITHUB_OUTPUT

      - name: Build and release Tauri app
        id: tauri-action
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          tagName: ${{ needs.prepare-release.outputs.tag }}
          releaseName: "mpesa2csv ${{ needs.prepare-release.outputs.tag }}"
          releaseBody: |
            ## What's New in v${{ needs.prepare-release.outputs.version }}

            ${{ steps.changelog.outputs.changelog }}

            ---

            ## üì• Installation

            Download the appropriate file for your platform from the assets below:

            - **Windows**: `mpesa2csv_*_x64-setup.exe`
            - **macOS Apple Silicon**: `mpesa2csv_*_aarch64.dmg`
            - **macOS Intel**: `mpesa2csv_*_x64.dmg`
            - **Linux**: `mpesa2csv_*_amd64.deb` or `mpesa2csv_*_amd64.AppImage`

            ### System Requirements
            - **Windows**: Windows 10 version 1903 or later
            - **macOS**: macOS 10.15 Catalina or later  
            - **Linux**: Modern distribution with GTK 3.24+ and WebKit2GTK 4.1+

            ---

            **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${{ steps.changelog.outputs.previous_version || '0.6.1' }}...v${{ needs.prepare-release.outputs.version }}
          releaseDraft: false
          prerelease: false
          args: ${{ matrix.args }}

  # Step 6: Generate and upload updater JSON
  generate-updater-json:
    name: "Generate Updater JSON"
    needs:
      [
        check-release,
        pre-release-validation,
        prepare-release,
        build-and-release,
      ]
    if: needs.check-release.outputs.should_release == 'true' && needs.pre-release-validation.outputs.validation_passed == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Generate and upload latest.json
        run: |
          echo "üîÑ Generating latest.json for Tauri updater..."

          VERSION="${{ needs.prepare-release.outputs.version }}"
          TAG="${{ needs.prepare-release.outputs.tag }}"

          # Create the latest.json file with proper Tauri updater format
          # Try to get release notes from the GitHub API
          RELEASE_NOTES="Update to version $VERSION. See full release notes at https://github.com/${{ github.repository }}/releases/tag/$TAG"

          # Try to fetch release notes from GitHub API
          if command -v gh &> /dev/null; then
            GITHUB_NOTES=$(gh api repos/${{ github.repository }}/releases/latest --jq '.body' 2>/dev/null || echo "")
            if [ -n "$GITHUB_NOTES" ] && [ "$GITHUB_NOTES" != "null" ]; then
              # Truncate if too long and clean up markdown
              RELEASE_NOTES=$(echo "$GITHUB_NOTES" | head -20 | sed 's/^## /## /g' | sed 's/^### /### /g')
            fi
          fi

          cat > latest.json << EOF
          {
            "version": "$VERSION",
            "notes": "$RELEASE_NOTES",
            "pub_date": "$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")",
            "platforms": {
              "darwin-aarch64": {
                "signature": "",
                "url": "https://github.com/${{ github.repository }}/releases/download/$TAG/mpesa2csv_aarch64.app.tar.gz"
              },
              "darwin-x86_64": {
                "signature": "",
                "url": "https://github.com/${{ github.repository }}/releases/download/$TAG/mpesa2csv_x64.app.tar.gz"
              },
              "linux-x86_64": {
                "signature": "",
                "url": "https://github.com/${{ github.repository }}/releases/download/$TAG/mpesa2csv_${VERSION}_amd64.AppImage"
              },
              "windows-x86_64": {
                "signature": "",
                "url": "https://github.com/${{ github.repository }}/releases/download/$TAG/mpesa2csv_${VERSION}_x64-setup.exe"
              }
            }
          }
          EOF

          echo "üìÑ Generated latest.json:"
          cat latest.json

          # Upload to the release
          echo "üì§ Uploading latest.json to release $TAG..."
          gh release upload "$TAG" latest.json --clobber
          echo "‚úÖ latest.json uploaded successfully"

          # Verify the file is accessible
          echo "üîç Verifying latest.json is accessible..."
          sleep 5  # Give GitHub a moment to process
          curl -f "https://github.com/${{ github.repository }}/releases/download/$TAG/latest.json" || echo "‚ö†Ô∏è latest.json not yet accessible"

          # Also verify the GitHub API endpoint works
          echo "üîç Verifying GitHub API endpoint..."
          curl -f "https://api.github.com/repos/${{ github.repository }}/releases/latest" | jq '.tag_name, .assets[] | select(.name == "latest.json") | .browser_download_url' || echo "‚ö†Ô∏è GitHub API endpoint not accessible"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Step 7: Create release branch for hotfixes
  create-release-branch:
    name: "Create Release Branch"
    needs:
      [
        check-release,
        pre-release-validation,
        prepare-release,
        build-and-release,
        generate-updater-json,
      ]
    if: needs.check-release.outputs.should_release == 'true' && needs.pre-release-validation.outputs.validation_passed == 'true'
    uses: ./.github/workflows/reusable-create-release-branch.yml
    with:
      version: ${{ needs.prepare-release.outputs.tag }}
      max_branches: 5
    secrets: inherit

  # Step 8: Notify about release completion
  notify-completion:
    name: "Release Complete"
    runs-on: ubuntu-latest
    needs:
      [
        pre-release-validation,
        prepare-release,
        build-and-release,
        generate-updater-json,
        create-release-branch,
      ]
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - name: Release summary
        run: |
          echo "üéâ Release ${{ needs.prepare-release.outputs.tag }} completed!"
          echo "‚úÖ Desktop binaries built and published"
          echo "‚úÖ Release branch created for hotfixes"
          echo "üîó View release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag }}"

          # Create a comprehensive release summary
          cat > release-summary.md << EOF
          # üöÄ Release ${{ needs.prepare-release.outputs.tag }} Summary

          ## ‚úÖ Completed Tasks
          - [x] Pre-release validation passed
          - [x] Version files synced
          - [x] Git tag created: ${{ needs.prepare-release.outputs.tag }}
          - [x] Desktop binaries built for all platforms
          - [x] GitHub release created
          - [x] Updater JSON generated
          - [x] Release branch created for hotfixes

          ## üìä Build Status
          - **Release Reason**: ${{ needs.check-release.outputs.release_reason }}
          - **Validation**: ‚úÖ Passed
          - **Desktop Builds**: ‚úÖ Success
          - **Release Creation**: ‚úÖ Success

          ## üîó Links
          - **Release**: https://github.com/${{ github.repository }}/releases/tag/${{ needs.prepare-release.outputs.tag }}
          - **Release Branch**: release/${{ needs.prepare-release.outputs.version }}
          - **Updater JSON**: https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/latest.json

          ## üì± Available Downloads
          - Windows x64: [Download .exe](https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/mpesa2csv_${{ needs.prepare-release.outputs.version }}_x64-setup.exe)
          - macOS Apple Silicon: [Download .dmg](https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/mpesa2csv_${{ needs.prepare-release.outputs.version }}_aarch64.dmg)
          - macOS Intel: [Download .dmg](https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/mpesa2csv_${{ needs.prepare-release.outputs.version }}_x64.dmg)
          - Linux x64: [Download .deb](https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/mpesa2csv_${{ needs.prepare-release.outputs.version }}_amd64.deb)
          - Linux Portable: [Download .AppImage](https://github.com/${{ github.repository }}/releases/download/${{ needs.prepare-release.outputs.tag }}/mpesa2csv_${{ needs.prepare-release.outputs.version }}_amd64.AppImage)

          ---

          **Release completed at**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          EOF

          echo "üìÑ Release summary created"
          cat release-summary.md
